## volatile的应用
### 定义
> 如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
### 实现
#### 1、将当前处理器缓存行的数据写回到系统内存。
> 如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。

1. 总线锁定
> 总线锁定即为当前处理器在Lock信号期间锁定总线，使得其他CPU不能访问总线，从而不能访问系统内存。
然而，这样同时也使得其他处理器不能访问系统内存中的其他变量，导致较大开销。
2. 缓存锁定
> 缓存锁定是指如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，缓存一致性机制会同时修改由两个以上处理器缓存的内存区域数据。


#### 2、这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
> ***缓存一致性协议***：每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。
### 使用优化
通过追加64字节的方式来提高并发编程的效率，简单了解。

## synchronized的实现原理与应用
Java中的每一个对象都可以作为锁。

具体表现形式有三种：
  1. 对于普通同步方法，锁是当前的实例对象。
  2. 对于静态同步方法，锁是当前类的Class对象。
  3. 对于同步方法块，锁是Synchonized括号里配置的对象。

> *当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。*


## 原子操作的实现原理
### CAS
> ***CAS Compare And Swap，其操作需要输入两个数值，一个旧值（期望操作之前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。***

### 什么是循环CAS？
> 循环CAS的基本思路就是通过循环执行CAS操作，直到执行成功跳出循环。
### CAS实现原子操作的三大问题
#### ABA问题
>ABA问题即为如果一个值原来是A，变成了B，后来又变成了A，那么使用CAS进行检查时会发现其值没有发生变化，而实际上却变化了。

详细示例参见：[CAS原理分析](https://blog.csdn.net/qq_37113604/article/details/81582784)

解决方案：使用版本号，在检查过程中同时检查版本号和变量值。
#### 循环时间长开销大
> 自旋CAS（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升.

>pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
#### 只能保证一个共享变量的原子操作
对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。

一个取巧的办法: 把多个共享变量合并成一个共享变量来操作。

## 本章小结
本章是《Java并发编程的艺术》第二章的内容，主要介绍了volatile，synchronized和原子操作的实现原理。

Java中的大部分容器和框架都依赖于本章介绍的volatile和原子操作的实现原理。

第三章内容比较多，等看完总结下再更新

拜了个拜~
