# Java内存模型的基础

本篇记录第三章Java内存模型的第一部分内容。

## 并发编程模型的两个关键问题

线程之间如何通信和线程之间如何同步

   1. 共享内存

        共享程序的公共状态，隐式通信。

        程序员必须显式指定某个方法/代码需要在线程之间互斥执行，显式同步。

   2. 消息传递

        没有公共状态，通过发送消息进行显式通信。

        消息发送总是在消息接收之前，因此为隐式同步。

Java并发采用第一种，即共享内存模型。

## Java内存模型的抽象结构

1. 线程共享内存

    堆内存，其中存有实例域，静态域和数组元素。

    JVM中的线程共享部分：Java堆，方法区。

2. 线程私有内存

    栈内存，包括局部变量，方法处理器参数，异常处理器参数。

    JVM中的线程隔离部分：虚拟机栈，本地方法栈，程序计数器。

3. JMM中定义的抽象关系

    > 线程之间的共享变量存储于主内存中，每个线程都有一个私有的本地内存。
    >
    >本地内存是抽象概念，现实中是涵盖了缓存，写缓存区，寄存器以及其他的硬件和编译器优化。
4. 线程A与线程B的通信示例

   (1) 线程A把本地内存A中更新过的共享变量刷新到主内存中。

   (2) 线程B到主内存中去读取线程A之前已更新过的共享变量。

    具体流程可参考下图。

![avatar](/pic/ThreadCrossCommunn.png)

## 从源代码到指令序列的重排序

重排序分三种类型：

    1. 编译器优化的重排序
    2. 指令集并行的重排序
    3. 内存系统的重排序

上述中，1属于编译器重排序，2和3属于处理器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器生成指令序列时，插入特定类型的内存屏障(Memory Barriers)指令，来禁止特定类型的处理器重排序。

JMM：Java内存模型，属于语言级的内存模型。

## 写缓存区的概念

### 定义

> 写缓存区：临时保存向内存中写入的数据。

### 作用

写缓存区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存中写入数据而产生的延迟。此外，还可以通过批处理式刷新和合并多次写来减少对内存总线的占用。

### 局限

> 每个处理器上的写缓存区，仅仅对它所在的处理器可见。

## happens-before简介

> 如果一个操作执行的结果必须对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。

**注意**：happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前，但是并不意味着前一个操作必须要在第二个操作之前执行。（关于此条后文详细说明）

如课本Page27图3-5所示，一个happens-before规则对应于一个或多个编译器和处理器重排序规则。

happens-before规则避免了程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。
