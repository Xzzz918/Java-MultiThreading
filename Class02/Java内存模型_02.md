# Java内存模型的顺序一致性

## 重排序

### 数据依赖性

> 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

编译器和处理器在重排序时，会遵循数据依赖性，不会改变两个存在数据依赖关系的操作的执行顺序。

**注意**：此处的数据依赖性仅针对**单个**处理器中执行的指令序列和**单个**线程中执行的操作。

### as-if-serial语义

> 不管怎么重排序，单线程程序的执行结果不能被改变。

as-if-serial语义保证了单线程下程序能正确地执行结果。

1. 程序员视角：程序是按照程序的顺序执行的。
2. 编译器、处理器、JMM视角：在不改变程序执行结果的前提下，尽可能提高并行度。

### 重排序对多线程的影响

示例代码（假定线程A执行writer()方法，线程B执行reader()方法）：

    public class ReorderExample {
    int a = 0;
    boolean flag = false;

    public void writer(){
        //下两行语句之间无数据依赖关系，可以对其进行重排序
        a = 2;
        flag = true;
        System.out.println("a = " + a);
    }

    public void reader(){
        //下两行语句之间存在控制依赖关系
        if (flag){  //3
            int i = a * a;    //4
            System.out.println( "i = " + i);    
        }
    }

    public static void main(String[] args) {
        ReorderExample r = new ReorderExample();
        Thread t1 = new Thread(r::writer);
        Thread t2 = new Thread(r::reader);
        t2.start();
        t1.start();
    }
    }    
以上程序的执行结果可能会发生改变。

比如，当线程A的flag=true语句率先执行时，随后线程B读取到这个变量flag，由于判定为真，线程B会读取变量a，但是这时候线程A还未将a的值写入，导致语义破坏。

此外，在以上代码中，操作3和操作4存在控制依赖关系，从而程序的执行结果可能会发生改变。

> 猜测执行：此处执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存在一个名为**重排序缓冲**的硬件缓存中，当操作3的条件判定为真时，就将其计算结果写入变量i中。

详情参见下图
![avatar](/pic/TimeSlotOfCodeRunning.png)

**小结**：在单线程程序中，对存在控制依赖的操作重排序不会改变执行结果（有as-if-serial语义保证）；但是多线程程序中可能会改变程序的执行结果。

### 顺序一致性与数据竞争

顺序一致性内存模型是一个**理论参考模型**。

**数据竞争**：

1. 在一个线程中写一个变量；
2. 在另一个线程中读一个变量；
3. 写和读没有通过同步来排序。

### 顺序一致性内存模型

理想化的模型，其拥有两大特性：

1. 一个线程中所有操作必须按照程序的顺序来执行。
2. （不管程序是否同步）所有线程看到的是一个单一的一致的执行顺序。

在顺序一致性模型中，每个操作必须立即对所有线程可见。（过于理想）

**在JMM中，以上几点均不保证。**

### 同步程序的顺序一致性效果

顺序一致性模型：完全按照程序顺序执行。

JMM：临界区内的代码可以重排序。

> JMM会在不改变（正确同步的）程序的执行结果的前提下，尽可能应用编译器和处理器对系统性能做出优化。

### 未同步程序的执行特性

没有什么新东西，关于处理器总线的工作机制：

> 在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读 / 写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的读 / 写。引用自课本Page36。

在任意时间点，最多只有一个处理器可以访问内存。这个特性保证了单个总线事务中的内存读 / 写操作具有原子性。
